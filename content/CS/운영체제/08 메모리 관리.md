---
date: 2024-06-04
---

# 1. 메모리 계층 구조와 메모리 관리 핵심

## 1.1 메모리 계층 구조

메모리

- cpu가 실행할 프로그램 코드와 데이터를 저장하는 물리 장치
- 메모리에 있는 코드와 데이터를 cpu 내부로 읽어와서 계산하고 결과를 메모리에 저장

메모리 계층 구조

- 읽기쓰기의 속도와 용량에 따라 기억장치의 계층 구조를 이루는 것
- cpu레지스터, 캐시 메모리, 메인 메모리, 보조기억장치 등
  ![[스크린샷 2024-06-04 10.36.17.png]]

##### 메모리 계층화, 성능과 비용의 절충

캐시 메모리

- cpu가 명령과 데이터를 가져오는 메모리 액세스 시간 단축을 위해 cpu와 메인 메모리 사이에 설치하여 사용
- cpu가 현재 실행하는 프로세스 코드와 데이터 중 당장 실행할 일부를 메인 메모리에서 가져다 놓고 실행하기 위한 메모리

> 메모리 계층 구조의 목적은 CPU의 메모리 액세스 시간을 줄이기 위함이다

##### 메모리 계층 구조의 각 요소

**cpu 레지스터**

- 현재 실행할 코드와 데이터 + 다음 실행할 코드와 데이터를 미리 저장할 목적
- 32~120 bite 저장공간

**캐시 메모리**

- 주기억장치로 사용하는 메인 메모리보다 더 빠른 메모리
- cpu의 빠른 처리속도에 맞추기 위해 도입

**메인 메모리**

- RAM
- 현재 실행중인 모든 프로세스의 코드와 데이터, 읽거나 쓰고있는 여러 파일들의 블록, 운영체제의 커널 코드와 커널 데이터들 저장
- 캐시메모리는 사용자 프로그램과 커널을 구분하기 않고 복사됨

**보조기억장치**

- 하드디스크와 SSD 같이 전원을 꺼도 지워지지 않는 대용량 저장 장치
- 파일이나 데이터베이스등을 저장할 목적으로 사용
- 메인메모리의 크기 한계로 인해 메모리에 적재된 프로그램 코드와 데이터의 일부를 일시 저장하는 용도로도 사용(스왑 영역)

|        |           cpu 레지스터           |               L1/L2 캐시                |                   L3 캐시                   |                              메인 메모리                              |                                    보조기억장치                                    |
| :----: | :------------------------------: | :-------------------------------------: | :-----------------------------------------: | :-------------------------------------------------------------------: | :--------------------------------------------------------------------------------: |
|  용도  |    몇개의 명령과 데이터 저장     | 한 코어에서 실행되는 명령과 데이터 저장 | 멀티 코어들에 의해 공유, 명령과 데이터 저장 | 실행중인 전체 프로세스들의 코드와 데이터, 입출력중인 파일 블록들 저장 | 파일이나 데이터베이스, 그리고 메모리에 적재된 프로세스의 코드와 데이터의 일시 저장 |
|  용량  | 바이트단위<br>8~30개<br>1KB 미만 |               KB 단위<br>               |                   MB 단위                   |                                GB 단위                                |                                      TB 단위                                       |
|  타입  |                                  |            SRAM(static ram)             |            SRAM(static ram)<br>             |                           DRAM(Dynamic ram)                           |                           마그네틱 필드 / 플래시 메모리                            |
|  속도  |               <1ns               |                  <5ns                   |                    <5ns                     |                                 <50ns                                 |                                       <20ms                                        |
|  가격  |                                  |                  고가                   |                    고가                     |                                 보통                                  |                                        저가                                        |
| 휘발성 |              휘발성              |               휘발성<br>                |                 휘발성<br>                  |                              휘발성<br>                               |                                      비휘발성                                      |

##### 프로그램의 실행과 메모리 계층 구조

운영체제가 보조기억장치에 저장된 실행파일을 메모리에 적재
-> 메인 메모리에 적재된 코드와 데이터 중 실행할 일부 코드와 필요한 데이터가 L3 캐시로 복사
-> L3 캐시에서 당장 실행할 코드와 데이터 일부분이 L1/L2 캐시로 복사
-> cpu 코어는 L1/L2 캐시에서 현재 실행할 명령과 데이터를 레지스터로 읽어들인 후 연산 실행

L1,L2,L3 캐시 = 선택사항
캐시가 없는 컴퓨터 -> cpu가 메인 메모리로부터 프로그램 코드와 데이터를 액세스하여 명령 실행
캐시를 가진 컴퓨터 -> cpu가 캐시로부터만 프로그램 코드와 데이터를 읽고 실행
![[스크린샷 2024-06-04 12.39.28.png]]

##### 메인 메모리와 캐시

cpu가 현재 프로세스나 스레드의 실행을 중단하고 다른 프로세스나 스레드를 실행
-> L1/L2 캐시에는 새로 실행하고자 하는 프로세스나 스레드의 명령과 데이터를 찾을 수 없는 **캐시 미스** 발생
-> 연쇄적으로 메인 메모리로부터 L3 캐시로, L3 캐시에서 L1/L2 캐시로 새 프로세스의 코드와 데이터 이동
-> 새로운 프로세스나 스레드 코드와 데이터가 캐시로 들어오기 전 현재 캐시에 들어있는 데이터중 수정된 데이터는 다시 L3캐시나 메인 메모리에 기록되어야 함
**= 오버헤드 발생**

캐시의 크기가 작기 때문에 프로그램 실행중에도 캐시 미스 발생
cpu가 액세스하는 코드나 데이터가 캐시에 없을 때 발생

##### 메인 메모리와 보조기억장치

프로세스가 새로운 메모리 할당을 요구하거나 새로운 프로세스 실행을 위해 메모리가 필요할 때 운영체제는 메인 메모리에서 빈 영역을 할당함
메인 메모리 전체가 사용중이거나 빈 영역이 일정 이하로 줄어듬 -> 메인 메모리에 적재된 코드나 데이터의 일부분을 하드 디스크나 SSD에 저장하고 메인 메모리에 빈 공간을 확부해둠

메인 메모리의 영역을 보조기억장치까지 확장하는 기법 : **가상 메모리(virtual memory)**

## 1.2 메모리 계층화의 성공 이유, 참조의 지역성

**참조의 지역성(locality of reference)**

- 코드나 데이터, 자원 등이 아주 짧은 시간 내에 다시 사용되는 프로그램 특성

## 1.4 메모리 관리

##### 메모리 관리 이유

**1. 메모리는 여러 프로세스에 의해 사용되는 공유 자원이다**
프로세스가 임의의 메모리 영역을 사용하게 할 수 없음
운영체제가 프로세스 별로 할당된 메모리 영역과 비어있는 영역을 관리해야 함
새로운 프로세스가 생싱되거나 프로세스 실행 중 메모리를 필요로 할 때 빈 메모리를 할당하고, 프로세스 소멸시 메모리를 반환하는 등 여러 프로세스가 메모리를 나누어 사용하도록 관리해야 함

**2. 메모리를 보호하기 위해서**
프로세스에게 할당된 메모리를 다른 프로세스가 접근하지 못하도록 보장
사용자모드에서 커널공간에 접근하지 못하도록 메모리 보호

**3. 메모리 용량 한계 극복을 위해**
시스템에 설치된 메모리가 부족할 경우에도 프로세스들을 정상적으로 실행시킬 수 있게 하기위해
디스크를 확장된 메모리처럼 사용하여 메모리의 물리적 한계를 극복하는 가상 메모리와 같은 메모리 관리 정책 필요

**4. 메모리 사용 효율을 높이기 위해**
다중프로그래밍정도(DOM) : 운영체제가 메모리에 동시에 적재하여 실행시키는 프로세스의 개수, 운영체제의 메모리 관리 효율성을 나타내는 지표
정해진 양의 메모리에 가능하면 많은 프로세스들을 실행시켜 시스템 처리율을 높이는 메모리 관리가 필요함

##### 메모리 관리 기능

**메모리 할당** : 여러 프로세스들이 컴퓨터 시스템의 메모리를 나누어 사용하도록 프로세스에게 적절히 메모리를 할당하는 기능
**메모리 보호** : 프로세스가 자신의 영역 외 다른 프로세스에게 할당된 메모리 영역이나 운영체제 영역을 침범하거나 훼손하지 못하도록 보호하는 기능

# 2. 메모리 주소

## 2.1 물리 주소와 논리 주소

- 물리 주소 - 실제 메모리 주소(하드웨어 주소)
- 논리/가상 주소 - 프로그램 내에서 사용되는 주소

> 물리 주소는 물리 메모리(ram)에 매겨진 주소로서 컴퓨터를 설계하고 제작하는 시점에 물리메모리에 매겨지는 하드웨어적인 주소이며 0번지부터 시작된다

컴퓨터 시스템 내부에 뻗쳐있는 주소버스에 연결되며 cpu 패키지 혹은 cpu 칩으로부터 발생된 이진 신호의 물리 주소가 주소 버스에 실려 물리 메모리로 전달됨

> 논리 주소는 프로세스 내에서 코드나 데이터의 주소이며 **가상 주소**와 동일한 의미로 사용된다

물리 메모리와 관계 없이 컴파일러에 의해 프로세스 내에서 매겨진 주소
프로세스 시작점이 논리 주소 0번지, 코드나 변수의 주소는 이 주소에 대한 상대 주소
사용자/프로그램 개발자나 프로그램/프로세스에서 사용하는 주소
운영체제가 응용프로그램을 실행시키기 위해 만들어놓은 프로세스 내에서 사용되는 주소

사용자나 프로세스 자신이 모든 메모리를 독점하여 사용하고 있다는 착각과 프로세스 코드와 변수들이 0번지부터 연속적으로 메모리에 적재되어있다는 착각 때문에 논리주소를 가상 주소라고 함
![[스크린샷 2024-06-04 13.12.51.png]]
프로세스 A의 논리주소 4번지 = 물리주소 8196번지
프로세스 B의 논리주소 0번지 = 물리주소 20480번지

cpu가 프로세스를 실행하는동안 다루는 모든 주소 = 논리주소
모든 프로세슨느 실행될때마다 다른 물리주소에 적재되지만 프로세스 내 적재된 코드와 변수의 논리주소는 항상 동일함

## 2.2 논리 주소의 물리 주소 변환

메모리를 액세스 하기 위해서는 논리 주소가 물리 주소로 바뀌어 물리 주소가 물리 메모리에 전달되어야 함

주소 변환 하드웨어(Address Translatoion H/W, MMU)

- cpu 내에 구성
- 프로세스의 논리 주소와 물리 주소의 매핑 정보를 담은 매핑 정보를 담은 매핑 테이블을 참고하여 논리 주소를 물리 주소로 변환
- 메모리 관리 방식에 따라 다르게 구현

> [!NOTE] CPU가 발생시키는 주소는 논리주소? 물리주소?
> mmu가 cpu 외부에 있었을 때 = 논리주소
> 현대 컴퓨터에서는 mmu가 cpu 패키지 내에 있어 cpu 패키지 바깥으로 나온느 주소는 물리주소
> 명령을 읽고 처리하는 기능 = cpu
> mmu나 캐시 등을 포함하는 경우 = cpu 패키지

## 2.3 컴파일과 논리주소

컴파일러는 사용자가 작성한 프로그램을 논리주소로 컴파일
컴파일 시점에서 응용 프로그램이 물리 메모리 몇번지에 적재될 지 알 수 없으므로 물리 주소로 컴파일하는것은 불가능
컴파일 후 생성된 실행 파일 내 모든 코드와 변수들은 논리 주소로만 구성

프로그램 실행 시작 시 운영체제는 프로세스를 생성하고 실행파일로부터 코드와 데이터 등을 적절한 물리 메모리에 적재 후 프로세스 별로 코드와 데이터가 적재된 물리 주소의 매핑 테이블을 만듬
mmu는 이 매핑테이블을 이용하여 cpu로부터 출력된 논리주소를 물리주소로 변환

매핑 테이블과 mmu덕분에 컴파일러는 프로그램을 논리 주소로 컴파일하는데 부담이 없고 운영체제 역시 프로세스의 코드와 데이터를 물리 메모리 빈 곳 아무데나 할당하고 적재 가능
같은 프로그램 실행 때마다 다른 번지의 물리 메모리에 적재되어도 문제 발생 x, 위치도 몰라도됨

# 3. 물리 메모리 관리

물리 메모리

- 컴퓨터 내에 설치되어 여러 프로세스들이 적재되고 실행되면서 공동으로 활용하는 실존 공간

## 3.1 메모리 할당

메모리 할당

- 운영체제가 새 프로세스를 실행시키거나 실행중인 프로세스가 메모리를 필요로 할 때 물리 메모리를 할당하는 것
- 프로세스 코드와 데이터 적재를 위해 물리 메모리 공간이 할당되고 프로세스의 실행 중 동적으로 스택이나 힙을 사용할 때 필요한 물리 메모리 공간이 할당되는데 메모리 할당은 전적으로 운영체제 커널에 의해 이루어짐

![[스크린샷 2024-06-04 15.10.26.png]]

## 3.2 연속 메모리 할당

연속 메모리 할당

- 각 프로세스에게 메모리 한 덩어리씩 할당하는 기법
- 고정 크기 할당 : 메모리 전체를 파티션(고정크기)으로 나누고 프로세스마다 1개의 파티션을 할당
- 가변 크기 할당 : 프로세스마다 프로세스 크기의 메모리 할당

## 3.3 분할 메모리 할당

분할 메모리 할당

- 프로세스에게 필요한 메모리를 여러 덩어리로 나누어 분산 할당하는 방법
- 가변 크기 할당 : 세그멘테이션, 프로세스에게 크기가 다른 여러개의 덩어리 메모리 할당
- 고정 크기 할당 : 페이징, 프로세스에게 동일한 크기의 덩어리를 여러개 할당

세그멘테이션 기법

- 프로세스를 여러개의 논리적인 덩어리로 분할하고 각 덩어리를 세그먼트라고 부름
- 프로세스 내에서 하나의 단위로 다룸
- 각 세그먼트의 크기는 다를 수 있음
- 프로세스를 구성하는 세그먼트들을 동일한 크기로 물리 메모리에 분산 할당
- 프로세스를 코드, 데이터, 스택, 힙의 4개 세그먼트로 분할하고 할당하는 방법 사용

페이징 기법

- 논리적인 단위로 분할하지 않고 논리주소 0번지부터 페이지라고 부르는 고정 크기로 분할
- 페이지와 동일한 크기로 분할하여 프레임이라고 부름
- 프로세스의 각 페이지를 물리 메모리 프레임에 하나씩 분산 할당

![[스크린샷 2024-06-04 15.31.30.png]]

# 4. 연속 메모리 할당

프로세스에게 1개의 연속된 메모리 블록을 할당하는 기법

- MS-DOS 와 같은 단일 사용자, 단일 프로세스 시스템에서의 연속 메모리 할당
- 고정 크기 할당
- 가변 크기 할당

## 4.1 고정 크기 할당

메모리를 파티션이라는 동일한 고정 크기로 나누고 프로세스에게 1개의 파티션을 할당하는 단순 기법
메모리 전체를 n개의 파티션으로 분할하고 프로세스를 실행시킬 때 각 프로세스에게 1개의 파티션 할당
n개의 프로세스가 실행되고 있을 때 새로운 프로세스가 도착하면 프로세스 하나가 종료될 때까지 작업 큐에서 대기

프로세스가 파티션 크기보다 작은 경우 - 메모리 일부 낭비
파티션 크기보다 큰 프로세서 - 처음부터 실행 불가
=> 시스템 운영자가 실행시킬 전체 응용프로그램들의 크기를 사전에 계산하여 파티션 크기를 정하는 방식으로 해결

![[스크린샷 2024-06-04 15.54.27.png]]

## 4.2 가변 크기 할당

프로세스의 크기가 모두 다른 것을 고려하여 각 프로세스에게 프로세스와 동일한 크기의 메모리 할당
리전(region) : 할당되는 메모리 공간
수용가능한 프로세스 개수는 가변적, 프로세스 도착 시 가용메모리가 부족하면 실행 중인 프로세스가 종료되어 필요한만큼 가용 공간이 생길 때까지 작업 큐에서 대기
![[스크린샷 2024-06-04 16.11.55.png]]

## 4.3 단편화(fragmentation)

단편화

- 프로세스에게 할당할 수 없는 작은 크기의 조각 메모리(홀)들이 생기는 현상
- 홀이 너무 작아 프로세스에게 할당할 수 없을 때 단편화 발생
- 홀이 생기는 위치에 따라 내부 단편화와 외부 단편화로 나뉨
- 단편화로 인한 메모리 낭비를 줄이는 메모리 할당 정책이 좋은 정책

##### 내부 단편화

프로세스에게 할당된 메모리 영역 내에 활용할 수 없는 홀이 생기는 경우
고정 크기 파티션에서 볼 수 있음
프로세스의 크기는 파티션 크기보다 작거나 같기 때문에 그 차이만큼 내부에 홀 발생
다른 프로세스에게 할당할 수 없는 낭비 메모리가 되기 때문에 홀이 생기는 현상을 내부 단편화라고 부름

##### 외부 단편화

할당된 메모리들 사이에 활용할 수 없는 홀이 생기는 경우
가변 크기 파티션에서 나타남
크기가 다른 파티션들이 할당되고 반환되기를 반복하면서 파티션과 파티션 사이 홀이 발생하는데 너무 작아 프로세스에게 할당할 수 없는 홀은 단편화를 초래함
외부 단편화로 인해 할당할 메모리가 부족해지면 파티션을 이동시켜 홀을 없애는 메모리 압축 기법을 사용
![[스크린샷 2024-06-04 16.16.43.png]]

## 4.4 연속 메모리 할당 구현

##### 하드웨어 지원

연속 메모리 할당을 위해 프로세스 실행중 논리 주소를 물리주소로 변환하는 기능과 프로세스가 다른 프로세스 메모리 액세스를 금지하는 기능이 구현되어야 함

- base 레지스터 - 현재 실행중인 프로세스에게 할당된 물리 메모리 시작 주소
- limit 레지스터 - 현재 실행중인 프로세스에게 할당된 메모리 크기
- 주소 레지스터 - 현재 액세스하는 메모리의 논리 주소
- 주소 변환 하드웨어(mmu) - 논리 주소를 물리 주소로 변환하는 장치

![[스크린샷 2024-06-04 16.21.28.png]]

```
mov ax, [300] - 논리 주소 300 번지의 데이터를 읽어 ax 레지스터에 저장
```

논리주소 300이 물리주소로 변환되어야 함
cpu가 주소 레지스터에 담긴 논리주소 300 출력, mmu는 base레지스터에 저장된 물리주소 1000과 논리주소 300을 더해 물리주소 1300을 만들고 cpu 패키지 바깥으로 내보냄
물리주소 1300이 주소 버스를 타고 메모리에 전달 - 메모리는 1300번지에 저장된 데이터를 데이터 버스에 내놓고 cpu가 이 값을 cpu 내부로 채어감

mmu는 논리 주소를 물리 주소로 바꾸는 전 단계에서 다른 프로세스 메모리 보호를 위해 논리 주소를 limit 레지스터의 값과 비교하여 할당된 메모리 범위를 넘어섰다면 바로 시스템 오류 신호를 발생시키는 회로 포함
시스템 오류 신호 발생 - cpu는 오류를 처리하는 커널 코드 실행, 현재 프로세스 강제 종료
=> 프로세스가 자신에게 할당된 영역을 넘어 다른 프로세스나 운영체제가 적재된 영역을 침범하지 못하도록 메모리 보호

##### 운영체제의 지원

연속 메모리 할당을 위해 모든 프로세스에 대해 프로세스 별로 할당된 물리 메모리 시작 주소와 크기 정보를 저장 관리하고 비어있는 메모리 영역 관리
새 프로세스를 스케줄링하여 실행시킬 때마다 프로세스의 물리 메모리의 시작 주소와 크기 정보를 cpu 내부의 base 레지스터와 limit 레지스터에 적재

## 4.5 홀 선택 알고리즘 / 동적 메모리 할당

프로세스가 실행되고 종료되는 과정을 거치면서 메모리가 할당되고 반환되기를 반복, 이 과정에서 메모리에 할당된 영역 사이에 홀들이 생김
프로세스를 처음 실행시키거나 프로세스의 실행 도중 메모리가 요구될 대 적당한 홀을 선택해서 할당해야 함
-> 홀 선택 알고리즘(동적 메모리 할당)

고정 크기 할당 : 홀(파티션) 들을 가용 메모리 리스트로 만들어 관리 후 선택
가변 크기 할당 : 메모리 전체에 걸쳐 있는 홀 마다 시작 주소와 크기 정보를 구성하고 홀 리스트로 만들과 관리해야 함, 메모리 할당 요청 발생시 홀 리스트에서 적절한 홀 선택

홀 선택 알고리즘

- first-fit(최초 적합) : 홀 리스트를 검색하여 처음으로 만나는 요청크기보다 큰 홀 선택, 속도는 빠르지만 메모리 낭비가 큼
- best-fit(최적 적합) : 홀 리스트를 검색하여 요청 크기를 수용하는 것 중 가장 작은 홀 선택, 홀 리스트가 크기별로 정렬되어있지 않으면 홀을 전부 검색해야 함
- worst-fit(최악 적합) : 홀 리스트를 검색하여 요청 크기를 수용하는 것 중 가장 큰 홀 선택, 정렬 안되있으면 전부 검색해야 함

![[스크린샷 2024-06-04 16.31.15.png]]## 4.6 연속 메모리 할당의 장단점

장점

- 알고리즘이 단순하여 구현이 용이
- 논리주소를 물리주소로 바꾸는 과정이 단순하여 메모리 액세스 속도가 상대적으로 빠름
- 분할 메모리 영역을 관리한느 부담에 비해 물리 메모리 영역의 시작 위치와 크기 정보만 관리하면 되므로 부담이 덜함

단점

- 메모리 할당의 유연성 부족
- 메모리 압축 과정 필요(홀들을 한쪽으로 모아 큰 빈 메모리 공간을 만드는 과정)
- 처음부터 프로세스에게 큰 메모리를 할당하면 내부 단편화를 초래하는 메모리 낭비가 될 수 있음

# 5. 세그멘테이션 메모리 관리

## 5.1 세그멘테이션 개요

세그먼트 : 세그멘테이션 메모리 관리 기법에서 프로세스를 구성하는 논리 블록
세그멘테이션 메모리 관리 기법 : 프로세스를 논리 세그먼트들로 나누고 각 논리 세그먼트에 한 덩어리의 물리 메모리를 할당하는 정책

- 코드 세그먼트 : 프로그램 전체에 걸쳐 작성된 모든 코드들을 모은 것
- 데이터 세그먼트 : 프로그램 전에체 걸쳐 선언된 전역 변수들과 정적 변수들
- 스택 세그먼트 : 함수가 호출될 때 지역 변수나 매개변수, 리턴값들을 저장하는 메모리 공간
- 힙 세그먼트 : 프로세스 실행 중 동적으로 할당받는 메모리 영역

세그먼트 기법으로 메모리 관리 => 컴파일러, 링커, 로더가 있어야 함
컴파일러, 링커 : 응용 프로그램과 라이버르리 코드를 한 군데로 모아 코드 세그먼트를 구성하고 전역 변수들과 정적 변수들을 모아 데이터 세그먼트를 구성한 후 실행 파일 생성
프로그램 실행 시 운영체제 로더는 실행 파일 내 구성된 논리 세그먼트에 대해 물리 메모리에서 동일 크기로 물리 세그먼트를 할당하고 논리 세그먼트를 물리 세그먼트에 적재
운영체제는 프로세스 실행시 필요한 크기의 스택 세그먼트와 동적 할당을 위한 힙 세그먼트를 물리 메모리에 할당

## 5.2 논리 세그먼트와 물리 세그먼트의 매핑

세그먼트 테이블

- 프로세스의 각 논리 세그먼트가 할당된 물리 메모리의 위치를 관리하기 위해 사용
- 프로세스 당 세그먼트 개수가 작기 때문에 시스템 전체에 1개의 세그먼트 테이블을 이용하여 현재 적재된 모든 프로세스들의 세그먼트들 관리
- 테이블 항목은 논리 세그먼트가 적재된 세그먼트 시작 물리주소와 세그먼트 크기로 구성되고, 세그먼트 테이블에 현재 실행중인 모든 프로세스에 대해 논리 세그먼트 당 하나의 항목 저장

프로세스가 실행되고 사라지는 과정이 반복되면 물리 세그먼트들 사이에 홀이 생기고 작은 홀들로 인해 외부 단편화가 초래됨
새로운 프로세스가 실행되면 각 세그먼트를 적재할 빈 홀을 찾기 위해 홀 선택 알고리즘 혹은 동적 메모리 할당 알고리즘 사용
![[스크린샷 2024-06-04 17.09.03.png]]

## 5.3 세그멘테이션의 구현

##### 하드웨어 지원

논리주소 구성

- 프로그램 코드나 데이터의 주소 - 세그먼트 내 상대주소로 컴파일되고 세그먼트에 번호가 매겨짐
- 세그먼트의 논리주소 = [ 세그먼트 번호(s), offset ]

cpu

- 세그먼트 테이블의 시작 주소를 가리키는 레지스터가 필요
- [세그먼트 번호, 옵셋]

MMU

- 메모리 보호 기능과 주소 변환 기능 구현
- 논리 주소가 세그먼트 크기를 넘어서는지 판별하는 기능과 논리 주소를 물리 주소로 바꾸는 기능
- cpu에서 논리 주소가 발생되면 메모리에 저장된 세그먼트 테이블에서 세그먼트 번호에 해당하는 항목이 읽혀지고, 이 항목의 limit값과 논리주소의 offset을 비교하여 offset이 limit보다 크면 논리 주소가 세그먼트 영역을 벗어났으므로 바로 시스템 오류를 발생시킴 작으면 세그먼트 테이블 항목에 들어있는 물리 세그먼트 시작 주소와 offset을 더해 물리 주솔르 출력
- 시스템 오류가 발생하는 경우 물리주소로 변환하는 회로는 작동하지 않음

세그먼트 테이블

- 세그먼트 테이블을 메모리에 둠
- cpu가 논리 주소를 발생하여 메모리를 액세스할 때마다 현재 세그먼트의 limit값과 base값을 알아내기 위해 메모리에 있는 세그먼트 테이블 항목을 읽어와야 해서 실행 속도에 부담이 됨
- 주소 변환 속도를 빠르게 하기 위해 세그먼트 테이블 일부를 mmu내에 두기도 함
  ![[스크린샷 2024-06-04 17.15.43.png]]

##### 운영체제 지원

현재 할당된 물리 세그먼트들의 리스트와 빈 메모리(홀)리스트로 만들고 관리해야 함
세그먼트 테이블을 생성, 관리, 유지해야 함
프로세스 생성시 논리 세그먼트를 적재할 물리 세그먼트를 빈 메모리 리스트에서 찾아 할당하고, 프로세스가 종료할 때마다 할당된 물리 세그먼트를 반환하는 기능을 가지고 있어야 함

##### 컴파일러, 링커, 로더 지원

세그멘테이션 기법이 컴퓨터 시스템에서 사용되기 위해 사용자 프로그램은 컴파일러에 의해 사전에 정의된 세그먼트들로 분할되고 링킹되어야 하며 기계 명령에 들어가는 메모리 주소는 [세그먼트 번호, 옵셋] 형식으로 컴파일 되어야 함
로더는 실행 파일에 만들어진 논리 세그먼트들을 인지하고 물리 메모리의 빈 영역을 할당받아 적재하며 세그먼트 테이블을 갱신해야 함

## 5.4 단편화

프로세스에게 가변 크기로 물리 세그먼트들을 할당하므로 외부 단편화가 필연적으로 발생
논리 세그먼트와 동일한 크기의 물리 세그먼트를 할당하기 때문에 내부 단편화는 없음
