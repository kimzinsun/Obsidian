---
date: 2024-05-07
---

#### 컴퓨터 시스템과 하드웨어

컴퓨터 시스템의 요소

- 응용 소프트웨어 층
- 운영체제 층
- 컴퓨터 하드웨어 층

![[스크린샷 2024-05-05 15.28.33.png]]

- 사용자는 응용프로그램이나 운영체제 패키지에 포함된 GUI와 도구 프로그램을 통해 컴퓨터를 활용
- 하드웨어들은 모두 운영체제의 배타적이고 독점적인 지배를 받음
- 어떤 사용자나 응용프로그램이라도 직접 하드웨어에 접근하는것은 허용되지 않고 반드시 운영체제를 통해서만 접근 허용
- 운영체제는 응용프로그램과 하드웨어와의 인터페이스를 제공하고 중계 역할 수행

#### 컴퓨터 하드웨어

![[스크린샷 2024-05-05 15.30.14.png]]

- CPU(Central Processing Unit) : 프로그램 코드를 실행하는 중앙 처리장치
- 메모리(Memory) : CPU에 의해 실행되는 프로그램 코드와 데이터가 적재되는 공간, RAM 사용
- 캐시 메모리(Cache Memory) : CPU의 프로그램 실행 속도를 높이기 위해 사용
- 장치들(Device)
- 버스(Bus) : 컴퓨터 하드웨어들이 서로 데이터를 주고받기 위해 0과 1의 디지털 신호가 지나가는 선을 다발로 묶어 부르는 용어
  - 주소 버스, 데이터 버스, 제어 버스
- 시스템 버스 : CPU, 캐시 메모리, 메모리 등 하드웨어 사이에 신호를 전송하기 위한 버스
- 입출력 버스 : 상대적으로 느린 입출력 장치들로부터 입출력 데이터를 전송하기 위한 버스
- 입출력 제어 장치 및 시스템 제어 회로 : 입출력 장치에게 명령을 내리고 메모리/CPU와 입출력 장치 사이에 데이터가 전달되도록 중계하는 역할

#### CPU와 메모리 관계

> CPU의 처리 능력 = 컴퓨터의 처리 능력

32비트 CPU

- 32개의 주소선을 가진 CPU
- 액세스할 수 있는 메모리의 최대 범위 = 4GB

![[스크린샷 2024-05-05 15.48.40.png]]

#### CPU 기계 명령

- CPU를 설계하는 기업이 CPU를 설계할 때 결정
- CPU에 따라 명령 개수와 형태가 다름

#### CPU의 일생

- 전원이 켜지는 순간부터 꺼질때까지 기계 명령을 실행하는 단순 과정 반복
- CPU명령 사이클

CPU 명령 처리 레지스터

- PC(Program Counter) / IP (Instruction Pointer) : 다음에 실행할 기계 명령의 메모리 주소 저장
- IR(Instruction Pointer) : 실행을 위해 메모리에서 읽어온 명령 저장
- SP(Stack Pointer) : 스택 영역의 꼭대기 메모리 주소 저장
- 데이터 레지스터 : 연산에 사용될 데이터 저장
- 상태 레지스터 : CPU의 상태 정보나 인터럽트 금지 등 제어 정보를 가지는 레지스터
- 기타 레지스터

CPU 명령 사이클

- CPU가 한 명령을 실행하는 과정

![[스크린샷 2024-05-05 16.07.14.png]]

1. CPU는 PC 레지스터에 저장된 주소(100)를 주소 버스에 싣는다
2. 메모리는 주소 버스로부터 주소(100)를 받고 100번지에 저장된 데이터를 데이터 버스에 싣는다
   - 이때 이 데이터가 mov eax [300] 명령 : 메모리 300번지의 데이터를 읽어 eax 레지스터에 저장
3. CPU는 데이터 버스에 담긴 바이너리 값들을 IR 레지스터에 저장하고 PC는 다음 명령의 번지로 수정된다
4. CPU는 연산에 필요한 데이터를 읽기 위해 데이터의 주소 300을 주소 버스에 싣는다
5. 메모리는 300번지에 저장된 값 50을 데이터 버스에 싣는다
6. CPU는 데이터 버스로부터 50을 CPU 내부의 임시 레지스터에 저장한다
7. CPU는 명령을 해석하고 실행한다.

#### 스택

프로그램 실행시 운영체제가 제공하는 4개의 공간

- 코드 공간 : 프로그램 코드 적재
- 데이터 공간 : 전역 변수들이 적재
- 힙 공간 : 동적으로 저장할 데이터를 위한 공간
- 스택 공간 : 함수 호출시 매개변수나 지역변수, 함수가 실행을 마치고 돌아갈 주소를 저장하기 위한 공간

> **스택이란 ?**
> 프로그램의 지역 변수 등을 저장하도록 할당된 메모리 영역
> 함수의 지역변수들, 매개변수 값들, 함수를 마치고 돌아갈 주소, 함수 코드가 의도적으로 스택에 저장한 값들이 저장

#### 컨텍스트

- 어떤 프로그램이 실행중인 일체의 상황 의미
- 현재 실행중인 프로그램의 컨텍스트를 현재 CPU에 들어있는 레지스터의 값들로 축소하여 정의

- 운영체제가 현재 실행시킨 프로그램을 중단하고 다른 프로그램을 실행시키고자 할 때 현재 실행중인 프로그램의 컨텍스트를 다른 곳에 복사해두어 다시 실행될 때 이용할 수 있음
- CPU의 레지스터들만 복사하면 됨

- 컨텍스트 스위칭 (context switching) - 현재 실행중인 프로그램의 컨텍스트를 저장해두고 다른 프로그램을 실행시키기 위해 다른 프로그램의 저장된 컨텍스트를 CPU로 옮기는 것 - 컨텍스트 정보들은 프로세스 제어블록(PCB, Process Control Block)에 저장됨
  ![[스크린샷 2024-05-05 16.21.28.png]]

#### 멀티코어 CPU

- 여러개의 코어를 가지고 동시에 여러 개의 프로그램을 실행할 수 있는 CPU

### 컴퓨터 시스템과 운영체제

#### 컴퓨터 시스템의 계층 구조

- 사용자, 응용 프로그램, 운영체제, 하드웨어들이 계층 구조(layered architecture)를 이루는 구조 - 계층간의 독립성 확보를 위해
  ![[스크린샷 2024-05-05 16.24.08.png]]

##### 운영체제 = 사용자/응용프로그램/하드웨어 사이의 매개체

> 운영체제와 **응용프로그램**
>
> - 응용프로그램이 직접 하드웨어를 다루지 못하도록 차단
> - 시스템 호출 함수를 이용하여 운영체제에게 서비스 요청
>
> 운영체제와 **사용자**
>
> - 사용자가 하드웨어에 대한 자세한 지식이 없어도 컴퓨터를 쉽게 다룰 수 있게 함
> - 새로운 하드웨어를 설치하거나 변경하는것을 도움
> - 컴퓨터 시스템을 사용할 편리한 사용자 인터페이스 제공
> - 컴퓨터의 사용을 돕는 여러 도구 응용프로그램 제공
> - 계정 관리 등
>
> 운영체제와 **하드웨어**
>
> - 하드웨어 제어, 입력값을 읽고 키 값을 전달하는 역할

#### 운영체제의 전체 기능

- 프로세스와 스레드 관리
  - 여러 프로세스/스레드를 동시에 실행시키기 위해 실행/일시중단/종료/스케줄링/컨테스트 스위칭 등의 기능 포함
  - 자원 사용시 충돌을 방지하기 위해 동기화 시키고 자원을 무한정 기다리는 일이 없도록 하는 기능 포함
- 메모리 관리
  - 프로세스/스레드 실행을 위한 메모리 할당, 반환, 보호 등
- 파일 관리 / 파일 시스템 관리
  - 파일 생성, 읽기, 복사, 삭제, 이동, 파일 보호등의 파일 관리 기능
- 장치 관리
  - 키보드, 마우스, 프린터 등의 입출력 장치나 하드 디스크 등의 저장 장치를 제어하여 사용자나 응용프로그램의 요청에 다라 입출력을 수행하는 기능
- 사용자 인터페이스
  - 사용자 친화적인 인터페이스 제공, 쉽게 사용하고 쉽게 실행시킬 수 있도로고 돕는 기능
- 네트워킹
  - 네트워크 사용을 위한 기능 제공
- 보호 및 보안

![[스크린샷 2024-05-05 16.47.51.png]]

- 커널 : 운영체제의 핵심 부분, 운영체제들의 기능 구현
  - 프로세스와 스레드 관리
  - 메모리 관리
  - 파일 생성, 삭제, 파일 입출력 등 파일 및 파일 시스템 관리
  - 디바이스 드라이버를 호출하여 장치 입출력
  - 커널코드는 함수의 형태로 존재, 응용프로그램에서 커널 함수를 시스템 호출(system call)방법으로 활용
- 도구 소프트웨어 : 사요아작 컴퓨터를 쉽게 활용하도록 돕는 소프트웨어
- 디바이스 드라이버 : 입출력장치를 구동하고 제어하여 실질적인 입출력을 수행하는 소프트웨어

#### 운영체제 커널 인터페이스 : 시스템 호출과 인터럽트

- 시스템 호출 : 커널과 응용프로그램 사이의 인터페이스
  - 응용 프로그램에서 커널 코드를 실행하는 기법
  - 운영체제가 응용프로그램을 대신하여 커널함수에 접근하는 시스템 호출 라이브러리 제공
- 인터럽트 : 하드웨어 장치들이 CPU에게 하드웨어 신호(인터럽트 신호)를 물리적으로 발생시켜 입출력이나 타이머 완료등을 CPU에게 알리는 방법
  - 인터럽트 서비스 루틴(ISR) : CPU가 인터럽트 신호를 받으면 현재 하던일을 멈추고 인터럽트 요청을 처리하는 코드 실행
  - 운영체제가 입출력 장치와 관련된 모든 이벤트 처리

### 커널과 시스템 호출

#### 응용 프로그램의 자원 접근 문제

단일 사용자/프로세스 운영체제 -> 한 번에 하나의 응용 프로그램만 실행되므로 응용 프로그램의 자원 접근에 대해 막을 필요 x
다중 사용자/프로세스에서 접근을 허용한다면?

- 다른 응용프로그램의 실행을 망칠 수 있음
- 컴퓨터 시스템이 복구 불가능한 문제에 빠질 수 있음

> 커널의 메모리 영역을 사용자 공간과 커널 공간으로 구분
> 실행모드를 사용자 모드와 커널모드로 나누어 실행

#### 사용자 공간과 커널 공간

사용자 공간 : 응용 프로그램이 적재되고 응용 프로그램의 변수가 만들어지고 동적 할당 받는 공간
커널 공간 : 커널 코드와 커널 데이터, 커널 함수들이 실행될 때 필요한 스택 공간, 디바이스 드라이버 등이 탑재되는 공간

> 응용 프로그램으로부터 커널 코드와 데이터를 지키기 위해 분리

사용자 공간과 커널 공간 -> 가상 주소 공간(virtual address space)

- 각 응용 프로그램이 0번지에서 시작하므로 주소 공간이 충돌하지 않는가?
  - 각 응용프로그램의 가상 주소 공간을 물리 메모리 공간으로 매핑시켜 충돌을 해결
- 컴퓨터에 장착된 물리 메모리(ram)의 크기가 부족한경우?
  - 물리 메모리의 일부를 하드 디스크에 저장하여 물리 메모리의 빈 영역을 확보하는 기법(가상메모리 기법) 사용

#### CPU의 사용자 모드와 커널 모드

사용자 모드인지 커널모드인지는 CPU 내의 모드 레지스터에 설정되며, 설정된 모드에 따라 서로 다르게 행동

|            구분            |                                                 사용자모드                                                 |          커널모드(특권모드, 감독자모드)          |
| :------------------------: | :--------------------------------------------------------------------------------------------------------: | :----------------------------------------------: |
|  CPU의 메모리 엑세스 범위  | 사용자 공간에 국한 커널 공간 액세스 불가<br>커널공간의 메모리 번지 접근 -> 시스템 예외 발생, 프로그램 종료 |     커널 공간을 포함한 모든 메모리 공간<br>      |
| CPU의 하드웨어 액세스 여부 |                                                    불가                                                    |            모든 하드웨어 액세스 가능             |
|   CPU가 처리 가능한 명령   |                                      특권 명령을 제외한 모든 CPU 명령                                      |         특권 명령을 포함한 모든 CPU 명령         |
|      오류 발생시 처리      |                        사용자 프로그램만 실행 종료, 시스템이 종료되지 않으므로 안전                        | 시스템에 심각한 오류가 발생한 것으로 시스템 종료 |

특권명령(privileged instruction) : 입출력장치나 타이머, 인터럽트 처리, 시스템 중단 등 특별한 목적으로 설계된 CPU 기계 명령

사용자 모드에서 커널 모드로 전환되는 경우

- 시스템 호출
  - 응용프로그램이 커널 안에 작성된 기능을 활용하기 위해 시스템호출 사용
  - 시스템호출을 일으키는 명령이 실행되면 사용자모드에서 커널모드로 변환
  - 시스템호출이 끝나고 프로그램으로 돌아갈 때 호출을 종료하는 명령에 의해 사용자 모드로 변환
- 인터럽트
  - 입출력장치나 저장장치나 CPU에게 인터럽트를 거는 경우 자동으로 커널 모드로 전환, 인터럽트 서비스 루틴(커널 공간에 있으므로 커널모드로 전환)으로 점프하여 실행
  - 인터럽트 서비스 루틴이 끝나면 다시 사용자 모드로 돌아가 응용 프로그램의 실행을 계속함

#### 특권명령

- I/O 명령

  - 하드웨어들을 제어하거나 입출력 장치나 저장장치를 제어하고 읽기/쓰기에 사용되는 CPU 기계 명령
  - I/O 포트: 그래픽카드나 네트워크 카드 등 입출력 장치들은 CPU가 액세스할 수 있는 여러개의 레지스터
  - 하드웨어 장치를 직접 접근하므로 커널모드에서 실행

- Halt 명령

  - 현재 처리할 작업이 없을때 CPU의 작동을 중지시키고 유휴(idle) 상태로 만듬
  - 전력 소모 감소

- 인터럽트 플래그 켜고 끄기

  - 인터럽트 플래그 : 인터럽트가 발생할 때 처리할지 무시할지 나타내는 비트

- 타이머 설정
- 컨텍스트 스위칭

#### 다양한 이슈들

- 사용자 모드와 커널 모드는 CPU에 의해 구현되는가 커널에 의해 구현되는가?
  - CPU에 의해 구현되어 운영체제가 활용
- 운영체제가 사용자 모드와 커널 모드로 나누어 작동시키는 이유는?
  - 커널 코드와 데이터에 대한 보안과 보호를 위해
- 응용프로그램이 커널 기능을 활용하는 방법?
  - 시스템 호출을 통해 커널 코드를 호출
- CPU가 커널 모드에서 실행되는 시간과 사용자 모드에서 실행되는 시간을 알 수 있는 방법?
  - 시스템 유휴 프로세스

#### 커널의 실체

> 커널은 부팅 시에 커널 공간에 적재되는 함수들과 데이터들의 집합

컴파일된 바이너리 형태로 운영체제가 설치되는 하드 디스크의 영역에 있다가 부팅시에 메모리에 적재되며 커널모드에서 실행될 함수들과 시스템을 관리하기 위한 여러 종류의 테이블과 구조체 등으로 구성

> 커널 코드는 함수들의 집합

실행중인 응용 프로그램 = 프로세스
커널 = 커널 공간에 적재된 함수들과 자료 구조들

> 커널은 프로세스가 아니다

커널이 프로세스들을 스케줄링한다 X -> 커널 함수가 프로세스 실행을 중단시키고 스케줄링 함수를 호출한다

> 커널은 실행중이 아니다

응용 프로그램의 시스템 호출이나 인터럽트에 의해 커널 코드가 실행중이다

> 커널은 스택이나 힙을 가지지 않는다

스택이나 힙은 프로세스(스레드)가 실행 중에 데이터를 저장하는 공간
프로세스가 생성될 때 커널모드에서 사용할 스택이 커널 내에 할당

#### 응용프로그램 빌딩

> 라이브러리?
> 응용프로그램에서 활용하도록 미리 함수들을 작성하여 컴파일하고 바이너리 형태로 만든 파일
> 응용프로그램 개발 시간 단축, 커널 함수를 대신 호출하는 역할

표준 라이브러리(standard library)

시스템 호출 라이브러리(system call library) = 커널 API

- 기계 명령을 이용하여 시스템 호출을 일으켜 커널 함수 실행

#### 사용자 코드와 라이브러리 코드 링킹

응용프로그램은 사용자가 작성한 함수들과 호출되는 라이브러리 함수들이 링크 과정을 거쳐 하나의 실행파일 내 결합되어 저장
실행파일은 사용자 공간에 적재

==> 모두 사용자 모드에서 실행됨

#### 함수 호출(function call)로 라이브러리 활용

사용자 함수들은 함수 호출을 통해 라이브러리 함수들 활용
함수 호출 과정은 커널 모드로 바뀌는 일 없이 **사용자모드** 에서 실행됨

#### 시스템 호출(system call)로 커널 코드 호출

응용프로그램이 하드웨어 관련 작업을 할 때 -> 시스템 호출 라이브러리에 작성된 시스템 호출 함수를 통해 간접적으로 커널 함수 호출
시스템호출 = 시스템 호출 핸들러 코드를 실행하는 과정
시스템 호출을 일으키는 기계명령을 실행시키고 레지스터를 통해 커널 함수의 고유 ID를 전달하고 이를 분석하여 해당 커널 함수 실행

#### 응용프로그램이 라이브러리와 커널 코드를 활용하는 과정

![[스크린샷 2024-05-07 10.32.37.png]]

### 시스템 호출

운영체제가 시스템 호출 라이브러리 제공
라이브러리 내 함수 = 시스템 호출 함수 / 커널 API

> Unix/Linux 커널 API - open(), read(), write(), fork(), exit()
> Windows 커널 API - CreateProcess(), WaitForSingleObject()

**시스템 호출은 응용프로그램에서 커널 기능을 하는 유일한 경로(interface)이다**

#### 시스템 호출을 일으키는 기계 명령

시스템 호출을 일으키는 기계 명령 = 시스템 호출 CPU 명령

호출하고자하는 시스템 호출 번호(커널 함수의 고유ID), 커널 함수에게 넘겨줄 파라미터등이 CPU 레지스터들에 미리 저장된 후 CPU 명령 실행
시스템 호출 CPU 명령을 실행하면 사용자 모드를 커널 모드로 바꾸고 시스템 호출 핸들러로 점프하여 실행 시작

> - read() 시스템 호출 함수를 이용하여 파일을 읽는 과정
>   ![[스크린샷 2024-05-07 10.42.39.png]]

#### 시스템 호출 종류

![[스크린샷 2024-05-07 10.45.43.png]]
![[스크린샷 2024-05-07 10.46.00.png]]

#### fread() 와 read()의 비용 비교

표준 라이브러리 함수 사용(fopen, fread) vs 시스템 호출 함수(open(), read())

![[스크린샷 2024-05-07 10.52.09.png]]

### 운영체제와 인터럽트

인터럽트

- 어떤 상황이 발생하였음을 CPU에게 알리는 하드웨어적 방법
- 장치들이 비동기적인 사건을 CPU에게 알리는 행위

1. CPU가 인터럽트 신호를 받는다
2. CPU가 프로그램의 실행을 멈추고 돌아올 주소를 저장한다
3. 발생한 인터럽트를 처리하는 서비스 루틴을 실행한다
4. 서비스 루틴이 끝나면 저장한 주소로 돌아가서 이전 프로그램 실행을 계속한다

#### 컴퓨터에서 인터럽트 활용

- 마우스 조작
- 키보드 입력
- 네트워크로부터 데이터 도착
- 하드디스크 쓰기 종료
- 시스템 클럭으로부터 일정한 시간 간격 알림
- 컴퓨터 리셋버튼
- USB 부착 / 삭제

#### 인터럽트 발생 및 처리 과정

인터럽트 처리 > CPU와 인터럽트 제어기등의 하드웨어가 상호 협력해야 함
![[스크린샷 2024-05-07 11.21.57.png]]APIC(Advanced Programmble Interrupt Controller)

- 여러 입출력 장치로부터 인터럽트를 받기위해 사용되는 하드웨어
- 인터럽트 제어기
- I/O APIC 와 Local APIC로 분리 구성
  - I/O APIC : 입출력장치로부터 직접 인터럽트 신호를 받는 장치
  - Local APIC : I/O API로부터 인터럽트 정보를 받아 CPU의 INTR 판에 직접 인터럽트 신호를 발생시키는 장치

여러 CPU가 있는 병렬 시스템에서 각 CPU마다 각 코어에 Local APIC 장치가 하나씩 연결됨
I/O APIC는 컴퓨터당 1개만 사용

#### 인터럽트 벡터 테이블

256개의 인터럽트에 대해 인터럽트 서비스 루틴(ISR)의 주소를 저장하고 있는 테이블

- 커널 영역에 저장되고 커널 코드에 의해서만 수정됨
- 부팅시에 만들어지고 ISR 주소들이 저장
- 인터럽트 벡터 테이블이 저장된 메모리 주소는 CPU 내의 레지스터에 저장되어 ISR의 주소를 알아낼때 이용

> 장치로부터 인터럽트가 발생 -> I/O APIC가 해당하는 IRQ의 인터럽트 벡터를 Local APIC에게 전송 -> Local APIC가 CPU에게 알림 -> CPU가 인터럽트 벡터 테이블에서 현재 발생한 인터럽트를 처리할 서비스 루틴의 주소를 알아내고 서비스 루틴 실행

인터럽트 친화성(interrupt affinity)

- 운영체제가 특정 인터럽트를 특정 Local APIC에게만 보내 특정 CPU 코어에서 인터럽트 서비스 루틴을 실행하도록 제어

#### 인터럽트 처리 과정

1. CPU가 응용 프로그램 실행중
2. 사용자가 키를 입력 -> 키보드가 전기적인 인터럽트 신호 전송
3. I/O APIC가 인터럽트 신호를 받음 -> 해당 인터럽트 핀(IRQ)에 설정된 인터럽트 벡터와 인터럽트를 처리할 타겟 코어의 Local APIC 번호를 메시지로 만들어 APIC 버스에 실어 보냄
4. Local APIC는 자신에게 향한 인터럽트 메시지를 받아 CPU의 INTR 판에 인터럽트 신호를 발생시키고 수신한 벡터는 CPU가 읽어갈 수 있도록 내부에 저장
5. INTR 신호를 받은 CPU는 Local APIC로부터 인터럽트 벡터를 읽음
   ---> 인터럽트가 발생하고 CPU가 인지하는 과정
6. CPU는 사용자 모드에서 커널 모드로 변경, 커널 공간에 저장된 인터럽트 벡터 테이블로부터 n번 항목에 저장된 인터럽트 서비스 루틴의 주소를 알아낸 후 현재 CPU가 실행중인 응용프로그램 컨텍스트를 잃어버리지 않기 위해 현재 PC와 SP, 플래그 레지스터등을 스택에 저장 후 플래그 레지스터의 IF 비트를 0으로 설정하여 다른 인터럽트를 받지 않도록 함
   ---> CPU가 2개의 APIC 사이에서 하드웨어적으로 진행되는 과정
7. 인터럽트 서비스 루틴 실행
8. 인터럽트 서비스 루틴 마짐가에 pop 명령으로 스택에 저장해둔 레지스터 복귀, 다음 인터럽트를 발생시킬 수 있도록 하고 인터럽스 서비스 루틴 종료
9. 응용 프로그램 실행 재개를 위해 스택에 저장된 pc, sp, 플래그 레지스터들을 CPU 코어로 복귀
10. 커널모드 -> 사용자모드로 변경되고 이전 응용프로그램 코드 실행

#### 인터럽트 서비스 루틴과 운영체제

인터럽트 서비스 루틴(인터럽트 핸들러) -> 디바이스 드라이버나 커널 코드에 저장

디바이스 드라이버 :

- 장치를 제어하여 장치로부터 입출력을 수행하는 프로그램
- 해당 장치로부터 발생한 인터럽트를 처리하는 서비스 루틴이 들어있음
- 장치와 커널 사이에 제어 명령과 데이터를 전달하는 인터페이스 역할
- 새로운 장치가 컴퓨터에 장착 -> 이 장치의 디바이스 드라이버를 설치하면 됨

![[스크린샷 2024-05-07 11.46.37.png]]

> 인터럽트가 있음으로 운영체제는 다중 프로그래밍 구현이 가능함
> 입출력 장치와 CPU가 동시에 각자의 일을 실행하게 하여 컴퓨터 시스템이 효율적으로 작동하게 함
> CPU의 활용율 / 시스템 처리율 향상
