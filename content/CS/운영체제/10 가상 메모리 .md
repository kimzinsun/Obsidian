---
date: 2024-06-10
---

# 1. 물리 메모리의 한계

## 1.1 주소 공간과 물리 메모리

> 32비트 cpu가 액세스 할 수 있는 물리 메모리의 최대 크기 = 2^32 바이트 = 4GB\

- 컴퓨터에 장착된 실제 메모리
- 프로세스가 실행 중 닿을 수 있는 최대 주소 범위 = 프로세스의 주소 공간

## 1.2 물리 메모리의 크기 한계

- 운영체제는 물리 메모리보다 큰 프로세스를 실행할 수 있는가?
- 운영체제는 여러 프로세스를 합쳐 물리 메모리보다 클 때 이들을 동시에 실행시킬 수 있는가?

# 2. 가상 메모리 개념

## 2.1 가상 메모리 개요

> **가상메모리(virtual memory)**
> 물리 메모리보다 큰 프로세스나 여러 개의 작은 프로세스를 동시에 실행시켜 사용자나 응용프로그램에게 무한대의 메모리가 있다고 느끼도록 하는 메모리 관리 기법

프로세스가 실행되기 위해서는 프로세스의 코드, 데이터, 스택, 힙 등 모든 영역들이 물리 메모리에 적재되어 있어야 한다는 전제를 깸

가상 메모리 기법의 핵심

- 물리 메모리를 디스크 공간으로 확장
- 스와핑(swapping)

##### 가상 메모리 개념

1. 물리 메모리 영역을 **하드디스크까지 연장**하고, 프로세스를 **물리 메모리와 하드디스크에 나누어 저장**한다
2. 프로세스가 실행될 때 **프로세스 전체가 물리 메모리에 적재되어 있을 필요는 없다**
   - 프로세스의 실행에 필요한 부분만 메모리에 적재하고 나머지는 하드 디스크에 저장해두고 실행에 필요할때만 물리 메모리로 이동시킨다
3. 물리 메모리에 빈 영역이 부족하면 **프로세스를 구분하지 않고 물리메모리 일부분을 하드디스크에 옮겨 빈 영역을 확보**한다
   - 최대한 많은 프로세스들을 메모리에 적재해 다중프로그래밍 정도를 높여 cpu활용률 + 시스템 처리율을 높인다
4. 물리 메모리를 확장하여 사용하는 디스크 영역을 **스왑 영역(swap area)**라고 부른다
   - 물리메모리 일부를 디스크로 옮기는 작업 - 스왑 아웃
   - 스왑 영역으로부터 물리 메모리로 적재하는 과정 - 스왑 인
5. 사용자는 **물리 메모리의 크기를 걱정하지 않고** 큰 프로그램을 작성할 수 있고 프로그램을 동시에 실행시킬 수 있다
   - 운영체제는 프로세스별로 어떤 부분이 물리 메모리에 적재되어 있고 어떤부분이 하드 디스크에 있는지 유지 관리하고 **프로세스에게 최소한의 물리 메모리를 할당하여 최대한 많은 프로세스를 실행시킨다**
6. 가상 메모리는 운영체제마다 구현 방법이 다르다

![[스크린샷 2024-06-10 14.24.14.png]]

##### 논리 주소와 가상 주소

프로그램/프로세스 내에서 사용하는 주소 = 논리 주소 , 가상 주소

## 2.2 가상 메모리 구현

- 요구 페이징(demand paging)
  - 페이징 기법을 토대로 프로세스의 일부 페이지들만 메모리에 적재하고 나머지는 하드디스크에 두며, 페이지가 필요할 때 메모리를 할당받고 페이지를 적재시키는 메모리 관리 기법
  - 요구페이징 = 페이징 + 스와핑
- 요구 세그먼테이션(demand segmentation)
  - 프로세스를 구성하는 일부 세그먼트들만 메모리에 적재해두고 다른 세그먼트가 필요할 때 메모리를 할당받아 세그먼트를 적재하는 메모리 관리 기법

현대 운영체제는 대부분 요구 페이징 기법을 사용한다

## 2.3 가상 메모리 기법에 대한 의문들

![[스크린샷 2024-06-10 14.28.50.png]]![[스크린샷 2024-06-10 14.29.00.png]]

# 3. 요구 페이징(demand paging)

## 3.1 요구 페이징 개념

> **요구 페이징**
> 물리 메모리 크기 한계 극복을 위해 페이징 기법을 기반으로 만들어진 가상 메모리 기법

- 프로세스의 페이지들을 **물리 메모리와 하드 디스크에 분산 할당**하는 방식
- 현재 **실행에 필요한 일부 페이지들만 물리 메모리에 적재**하고 나머지는 하드 디스크에 둠으로써 많은 프로세스 실행
- 실행에 필요한 첫 페이지만 물리 메모리에 적재하여 실행, 실행 중 없는 페이지를 참조하게 되었을 때 물리 메모리의 빈 프레임을 할당받고 페이지 적재

> 요구(demand) : 페이지가 필요할 때 까지 물리 메모리에 적재하지 않다가 페이지가 필요할 때 물리 메모리를 할당받고 디스크에서 읽어 적재시킨다는 의미

## 3.2 요구 페이징 구성

![[스크린샷 2024-06-10 14.48.15.png]]

##### 디스크의 스왑 영역

- 메모리에서 쫓겨난 페이지들이 저장되는 영역
- 시스템 관리자가 위치와 크기 결정
- 리눅스 - 스왑 파티션 사용, 윈도우 - 특정 파일(C:\pagefile.sys) 스왑 영역으로 사용

##### 페이지 테이블

- presence/valid 비트 - 페이지가 메모리에 적재되어 있는지를 나타내는 비트
  - 1 : 물리 메모리, 0 : 디스크
- modified/dirty 비트 - 페이지가 메모리에 적재된 후 수정되었는지를 나타내는 비트
  - 1 : 해당 페이지가 물리 메모리에 적재된 후 수정됨
  - 0 : 수정된 적이 없음, 스왑 영역에 있는 상태
- physical address 필드
  - 페이지가 메모리에 적재되어 있는 경우 = 물리 프레임의 번호 기록
  - 물리 메모리에 없는 경우 = 디스크 주소(디스크 블록 번호) 기록

##### 페이지 폴트

> cpu가 가상 주소를 발생시켜 액세스하려는 페이지가 **현재 물리 메모리에 없을 때** 페이지 폴트(page fault)라고 한다

페이지 폴트 발생 -> 페이지 폴트 핸들러 코드 실행

- 물리 메모리에 서 빈 프레임을 할당받고 요청된 페이지를 하드 디스크에 읽어 적재하고 페이지 테이블 수정
- 빈 프레임이 없는 경우 -> 희생 프레임 선택 (페이지 교체 알고리즘 사용)

- 스왑-인(swap-in) : 페이지를 스왑 영역으로부터 프레임에 적재하는 것
- 스왑-아웃(swap-out)/페이지-아웃(page-out) : 프레임에 적재된 페이지를 스왑 영역에 저장하는 것

페이지 히트 : cpu가 발생한 가상 주소 페이지가 메모리 프레임에 있을 때

## 3.3 페이지 폴트 자세히 알기

![[스크린샷 2024-06-10 15.00.14.png]]

```
mov eax, 10 -- eax 레지스터에 10 저장
mov [11111234], eax -- eax 레지스터 값을 0x1111234 번지에 저장
```

![[스크린샷 2024-06-10 14.58.58.png]]

## 3.4 요구 페이징 시스템에서 프로세스 실행

![[스크린샷 2024-06-10 15.36.25.png]]

1. 프로세스의 시작 페이지 적재 - 메모리 프레임 1개 할당 - 실행 파일로부터 프로세스의 실행이 시작될 첫 페이지를 적재한 후 프로세스 실행
   ![[스크린샷 2024-06-10 15.04.40.png]]
2. 여러 번의 페이지 폴트를 통해 실행 파일로부터 페이지들 적재 - 실행 초기에는 페이지 폴트가 연이어 발생, 폴트가 발생한 페이지는 **실행 파일이나 스왑 영역**에 위치
   ![[스크린샷 2024-06-10 15.21.06.png]]
   ![[스크린샷 2024-06-10 15.33.41.png]]
3. 메모리가 부족하면 스왑-아웃/스왑-인 - 페이지 100이 들어있는 프레임을 희생 프레임으로 선택
   ![[스크린샷 2024-06-10 15.38.36.png]]
4. 스왑-아웃된 페이지 100을 다시 스왑-인
   ![[스크린샷 2024-06-10 15.41.43.png]]
5. 수정된 페이지는 스왑 영역에 쓰기

## 3.5 쓰기 시 복사(COW, copy on write)

##### 완전 복사

- 프로세스는 부모 프로세스에 의해 생성되며 시스템 호출을 통해서만 이루어짐
- fork() : 부모 프로세스의 메모리를 모두 복사하여 자식 프로세스 생성

##### 완전 복사의 비효율성

fork() 시스템 호출이 부모 프로세스와 동일한 크기의 메모리를 할당받고, 부모 프로세스의 메모리를 완전 복사하여 자식 프로세스를 생성해도 곧바로 execlp()를 호출하여 할당받은 메모리를 모두 반환하고 다시 페이지를 적재하기 때문에 비효율적이다.

##### 쓰기 시 복사로 완전 복사 문제 해결

부모 프로세스의 메모리를 복사하지 않고 자식 프로세스가 부모 프로세스의 메모리를 완전히 공유하도록 하고 둘 다 실행되도록 내버려둔다. 그 후 부모든 자식이든 실행 중 메모리 쓰기가 발생하면 그 때 운영체제는 쓰기가 발생한 페이지만 새 프레임을 할당받아 복사한다. 페이지를 읽는 경우에는 복사하지 않는다.
![[스크린샷 2024-06-10 16.04.51.png]]

##### 쓰기 시 복사의 장점

- 프로세스 생성시간 절약
- 메모리 절약

## 3.6 페이지 폴트와 스레싱

##### 페이지 폴트와 디스크 I/O

페이지 폴트가 발생하면 디스크 입출력이 동반된다

- 필요 페이지를 적재하거나 프레임을 비우기 위해 스왑-아웃 시키기 때문

##### 스레싱

> 페이지 폴트가 계속 발생하여 메모리 프레임에 페이지가 반복적으로 교체되고 디스크 입출력이 심각하게 증가하고 cpu 활용률이 대폭 감소하는 현상

= 빈번한 페이지 폴트로 인한 디스크 입출력 증가 현상
= 디스크 스레싱

##### 스레싱의 원인

1. 다중 프로그래밍 정도가 과도한 경우
2. 메모리 할당 정책이나 페이지 교체 알고리즘이 잘못되었을 경우
3. 컴퓨터 시스템에 설치된 메모리가 절대적으로 작은 경우
4. 특정 시간대에 너무 많은 프로세스를 실행한 경우

##### 스래싱 현상 관찰

스레싱을 방치하면 cpu 활용률이 떨어지고 프로세스들의 응답시간이 떨어지며 시스템 처리율이 감소한다.

![[스크린샷 2024-06-10 16.13.15.png]]
동시에 실행되는 프로세스의 개수가 늘어날수록 cpu 활용률이 증가함
임계점 M을 넘어갈 때부터 cpu 활용률이 떨어짐

- 상대적으로 각 프로세스에게 할당되는 프레임의 개수가 줄어들고 각 프로세스는 실행에 필요한 페이지들을 모두 메모리에 적재하지 못하게 되어 계속 페이지 폴트가 발생함
- 빈번한 스왑-아웃/스왑-인으로 인해 디스크 입출력이 증가하고 cpu의 대기시간이 늘어 활용률 급감
- -> 스레싱이 시작되는 시점

> 동시에 실행되는 프로세스의 개수가 많음에도 불구하고 오히려 cpu 활용률이 갑자기 떨어질 때 스래싱이 발생하기 시작한 것으로 판단할 수 있다.

##### 스래싱 해결 및 예방

스래싱이 발생한 상태 = 몇 개의 프로세스를 강제로 종료시켜 다중 프로그래밍 정도를 낮추어야 함
스래싱을 예방하기 위해서는 다중 프로그래밍 정도의 시스템 허용치를 낮추어 설정하거나, 컴퓨터의 메모리를 늘리거나, SSD를 사용한다.
