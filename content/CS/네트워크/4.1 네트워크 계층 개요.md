### 4.1 포워딩과 라우팅

네트워크 계층의 근본적인 역할 : 송신 호스트에서 수신 호스트로 패킷 전달

- 포워딩(전달)
	- 라우터의 입력 링크에 패킷이 도달했을 때 그 패킷을 적절한 출력 링크로 이동
	- 매우 짧은 시간 소요, 하드웨에서 실행
	- 한 교차로를 지나는 과정, 교차로에서 어느 도로로 들어설지 결정
- 라우팅
	- 패킷을 전송할 때 패킷 경로를 계산
	- 계산하는 알고리즘을 라우팅 알고리즘 이라고 함
	- 네트워크 계층의 제어 평면에서 실행
	- 긴 시간 단위 소요, 소프트웨어에서 실행
	- 여행 전체를 계획하는 과정

- 포워딩 테이블
	- 도착하는 패킷 헤더의 필드값을 조사하여 패킷 전달
	- 이 값을 네트워크 포워딩 테이블의 내부 색인으로 사용
	- 헤더의 값 : 패킷이 전달되어 할 외부 링크 인터페이스, 패킷의 목적지 주소이거나 패킷이 속한 연결의 지시

#### 제어평면 : 전통적인  접근 방법

라우팅 알고리즘
- 포워딩 테이블 내용 결정
- 모든 라우터에서 실행
라우터
- 포워딩과 라우팅 기능 모두 가짐
- 한 라우터의 라우팅 알고리즘은 다른 라우터의 라우팅 알고리즘과 소통하며 포워딩 테이블 값 계산
- 소통은 라우팅 정보에 포함된 라우팅 메시지를 교환하며 이루어짐

#### 제어평면 : SDN 접근 방법

- 원격 컨트롤러가 데이터 센터에 설치되어 isp 나 제 3자에 의해 관리
- 원격 컨트롤러와 라우터는 포워딩 테이블과 라우팅 정보를 포함한 메시지 교환으로 소통
- SDN(Software defined networking)
- 네트워크가 소프트웨어적으로 정의되었을 때 포워딩 테이블을 계산하는 컨트롤러는 라우터와 상호작용하며 소프트웨어에서 실행

![[JPEG 이미지-40FE-9BF9-88-0.jpeg]]

#### 4.1.2 네트워크 서비스 모델

네트워크 서비스 모델(network service model) 
	: 송수신 호스트 간 패킷 전송 특성 정의
- 보장된 전달 : 패킷이 출발지 호스트~목적지 호스트까지 도착 보장
- 지연 제한 이내의 보장된 전달 : 전달 보장 + 특정 지연 제한 안에 전달
- 순서화 패킷 전달 : 송신 순서대로 도착 보장
- 최소 대역폭 보장 : 송신 호스트가 비트들을 특정한 비트율 이하로 정송하는 한 모든 패킷이 목적지 호스트까지 전달
- 보안 서비스 : 트랜스포트 계층의 모든 세그먼트에 대해 기밀성 유지

### 4.2 라우터 내부에는 무엇이 있을까?

라우터의 4가지 요소
- 입력 포트
	- 입력 링크 : 물리 계층 기능 수행
	- 들어오는 링크 반대편 링크 계층과 상호작용 : 링크 계층 기능 수행
	- 입력 포트에서 검색기능 수행 : 포워딩 테이블을 참조하여 스위치 구조를 통해 라우터 출력 포트 결정
	- 제어패킷(라우팅 프로토콜 정보 전달 패킷)은 입력 포트에서 라우팅 프로세서로 전달
	- ![[JPEG 이미지-4C97-BAEC-8D-0.jpeg]]
- 스위치 구조
	- 라우터의 입력 포트와 출력 포트 연결
	- 라우터 내부에 포함
- 출력 포트
	- 스위치 구조에서 수신한 패킷을 저장하고 필요한 링크 계층 및 물리 계층 기능을 수행하여 출력 링크로 패킷 전송
- 라우팅 프로세서
	- 제어 평면 기능 수행
	- SDN 라우터에서 원격 컨트롤러와 통신하여 포워딩 테이블 엔트리를 수신하고 라우터 입력 포트에 엔트리 설치
	- 네트워크 관리 기능 수행

라우터의 입출력포트와 스위치 구조 = 하드웨어로 구현
라우터의 (제어기능을 하는)제어평면 = 소프트어어로 구현, 라우팅 프로세서에서 실행

패킷 전송에 필요한 정보
- 목적지 기반 포워딩
	- 입력 포트에서 최종 목적지를 검색하고 최종 목적지로 연결되는 스위치 구조의 출력포트를 결정한 후 알려줌
- 일반화된 포워딩
	- 목적지 외에 다양한 요인이 출구 선택에 관여


#### 4.2.1 입력 포트 처리 및 목적지 기반 전송

1) 검색 기능
- 포워딩 테이블을 사용하여 도착 해킷이 스위치 구조를 통해 전달되는 출력 호트 검색
	- 포워딩 테이블 : 라우팅 프로세서(라우팅 프로토콜 사용)에서 계산되거나 갱신되거나 원격 SDN 컨트롤러에서 수신, 입력 라인카드로 복사
	- 복사본을 사용하면 패킷 단위로 중앙 집중식 라우팅 프로토콜 수신하지 않아 병목 현상을 피할 수 있음

포워딩 테이블 구현
![[JPEG 이미지-48C0-99A3-FD-0.jpeg]]
패킷의 목적지 주소의 프리픽스를 테이블 엔트리와 매치

![[JPEG 이미지-4DE1-834B-B3-0.jpeg]]
매치되는 엔트리가 존재하면 라우터는 매치에 연관된 링크로 패킷 전송
- 목적지 주소가 1개 엔트리 이상에 매치 될 수 있다
- 다수의 매치 = 최장 프리픽스 매치 규칙 사용
	- 테이블에서 가장 긴 매치 엔트리를 찾고 여기에 연관된 링크 인터페이스로 패킷 전송

하드웨어 로직은 포워딩 테이블을 사용하여 가장 긴 프리픽스와 매치되는것을 찾음

검색을 통해 출력포트 결정 -> 패킷을 스위치 구조로 전송
다른 입력 포트로부터 패킷이 현재 구조 사용 -> 패킷이 스위칭 구조에 들어가는것을 일시적으로 차단
차단된 패킷은 입력 포트에 대기한 다음 구조를 교체하도록 예약

2) 물리 및 링크 계층 처리
3) 패킷의 버전 번호, 체크섬, TTL(time-to-live) 필드를 확인하고 재사용
4) 네트워크 관리에 사용되는 카운터(수신된 IP 데이터 그램 수) 갱신

#### 4.2.2 스위칭
스위치 구조 : 패킷이 입력 포트에서 출력 포트로 실제로 스위칭(포워딩)되는 구조를 통과

스위칭 방법 3가지
- 메모리를 통한 교환
	- 초기의 라우터 : CPU를 직접 제어해서 입력 포트와 출력 포트 사이에서 패킷 스위칭
	- 최근 라우터 : 메모리를 통해 스위칭
		- 목적지 주소를 검색하고 해당 메모리 위치에 패킷을 저장하는 것이 입력 라인 카드에서 처리함으로써 수행
- 버스를 통한 교환
	- 라우팅 프로세서 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷 전송
	- 미리 준비된 입력 포트 스위치 내부 레이블이 로컬 출력 포트를 나타내는 패킷에게 전송되거나 버스에 패킷을 전송하여 수행
	- 레이블과 매치되는 포트만 패킷 유지
	- 동시에 여러 패킷이 도착하면 하나의 패킷만 버스를 통과할 수 있기 때문에 나머지는 대기
	- 라우터 교환 속도는 버스 속도에 의해 제한
- 상호연결 네트워크를 통한 교환
	- 공유 버스의 대역폭 제한 극복 : 복잡한 상호 연결 네트워크 사용
	- 크로스바 스위치 : 여러 패킷을 병렬로 전달 가능, 그러나 동일한 출력 포트로 보내지는 경우 한번에 하나의 패킷만 전송될 수 있기 때문에 입려겨 대기
	- 다단계 스위치 구조 : 여러 단계의 스위칭 요소 사용

#### 4.2.3 출력 포트 처리

출력 포트의 메모리에 저장된 패킷을 가져와 출력 링크를 통해 전송
전송을 위한 패킷 선택, 큐 제거, 필요한 링크 계층 및 물리 계층 전송 기능 수행 포함

#### 4.2.4 어디에서 큐잉이 일어날까?

패킷 큐 -> 입력 포트와 출력 포트 모두에서 형성
큐의 위치와 범위 -> 트래픽 로드, 스위치 구조의 상대 속도, 라인 속도에 따라 달라짐
큐가 커지면? 패킷 손실 발생

패킷은 네트워크 내에서 손실되거나 라우터에서 감소됨

입력 및 룰력 라인의 속도는 초당 Rvline 패킷으로 동일한 전송률
N개의 입력포트와 N개의 출력 포트가 있다고 가정

패킷이 입력 포트에서 출력 포트로 이동할 수 있는 속도로 스위치 구조 전송률은 Rvswitch로 정의
Rvswitch가 Rvline 보다 N배 빠르다면 입력 포트에서 발생하는 큐잉 무시
-> 스위치 구조를 통해 삭제 가능

##### 입력 큐잉
스위치 구조는 한 번에 하나의 패킷만 지정된 출력 포트로 전송 가능
![[JPEG 이미지-471C-AAD4-51-0.jpeg]]
4번 = HOL(head-of-the-line) 차단
- 라인의 앞쪽에서 다른 패킷이 막고 있으므로 입력 큐에서 대기중인 패킷은 사용할 출력 포트가 사용중이지 않아도 스위치 구조를 통해 전송되기 위해 대기

##### 출력 큐잉

출력 포트는 시간단위에 단일 패킷만 전송할 수 있기 때문에 N개의 도착 패킷은 출력 링크를 통한 전송 큐에서 대기
N개의 패킷중에서 하나를 전송할 때 다시 N개의 패킷이 도착할 수 있으므로 속도가 N배 빠른 경우에도 패킷 큐잉 발생

저장 메모리가 충분하지 않을 경우
1) 도착한 패킷 삭제(drop-tail) 
2) 이미 대기중인 하나 이상의 패킷 제거
3) 버퍼가 가득 차기 전에 패킷을 삭제하여 송신자에게 혼잡 신호 제공

AQM(active queue management)알고리즘 
- 패킷 삭제와 패킷 마킹 정책이 제안되거나 분석
- RED(Random Early Detection)
- PIE(Proportional Integral controller Enhanced)

![[JPEG 이미지-4EBB-A4D7-C3-0.jpeg]]


- 시각 t에서 패킷이 입력 포트에 도달, 각각의 포트는 맨 앞 출력 포트로 향함
- 2개의 패킷이 스위치 수신에 도착
- 패킷 중 하나가 맨 앞의 출력 포트로 전송
	- 출력 포트의 패킷 스케줄러가 전송 대기중인 패킷 중 하나의 패킷을 선택

##### 얼마나 많은 버퍼가 요구되는가?
이전 버퍼 크기에 대한 규칙
- 링크 용량이 C일 때, 버퍼링의 양(B)은 평균 왕복 시간(RTT)와 같아야 한다
최근 규칙
- 많은 수의 독립적인 TCP 흐름(N)이 링크를 통과할 때 필요한 버퍼링은 B=RTTxC/루트(N) 이라고 제안

버퍼링이 클 수록 라우터의 패킷 손실을 감소시킬수있다 => 라고 생각 x
버퍼가 클수록 큐잉 지연이 길어진다

버퍼링은 트래픽의 단기 통계 변동을 흡수하는 데 사용될 수 있지만 지연을 증가시킬 수 있다

독립적인 송신자들이 혼잡한 링크에서 대역폭과 버퍼를 놓고 경쟁하고 있다
=> 네트워크 가장자리에서는 유지 x

ACK 클록은 대기중인 패킷이 있을 때마다 새 패킷이 큐에 도착하게 되고 전송되어 홈 라우터의 송신 링크에서 큐 크기가 항상 유지된다
(패킷이 전송될때 계속 들어와서?)

종단간 파이프는 꽉 찼지만 큐잉 지연의 양은 일정하고 지속적이다

= 홈 네트워크에 다른 트래픽이 존재하지 않는 경우에도 지연이 지속적으로 지나치게 긴 이유를 이해하지 못한다

=> ==버퍼블로트 (패킷의 과도한 버퍼링으로 인해 생기는 패킷 교환 네트워크의 높은 대기 시간의 원인)

처리량뿐만 아니라 최소 지연도 중요하며 네트워크 가장자리와 네트워크 내 큐에서 송신자 간의 상호작용이 실제로 복잡하고 미묘할 수 있음을 보여줌

