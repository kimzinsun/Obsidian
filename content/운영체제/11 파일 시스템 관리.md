---
date: 2024-06-10
---

# 1. 파일 시스템과 저장 장치

## 1.1 파일과 저장 장치

파일(file) : 정보를 저장하고 관리하는 논리적인 단위

- 파일을 저장하는 저장 정치는 비휘발성 영구 저장 장치
- 파일이 생성되고 기록되고 읽혀지는 모든 과정은 운영체제에 의해서만 통제됨

## 1.2 디스크 장치 개요

- 하드 디스크 : 자성체로 코팅된 여러개의 원판(플래터)에 디지털 정보를 저장하고 읽어내는 장치, 디스크 매체 모듈과 디스크 제어 모듈로 구성됨

![[스크린샷 2024-06-18 10.43.07.png]]

##### 디스크 매체 모듈

- 플래터(platter) : 정보가 기록되는 저장소, 스핀들에 연결되어 함께 회전
- 디스크 헤드(disk head) : 플래터 표면과 일정 간격을 유지한 채 플래터에서 정보를 읽거나 기록

##### 디스크 제어 모듈

- 프로세서(processor) : 호스트 컴퓨터의 운영체제로부터 명령을 받고 해석한뒤 디스크 매체 모듈을 제어하여 물리적인 디스크 액세스를 진행시킴
- 디스크 캐시(disk cache) : 입출력 데이터를 임시 저장하는 장치, 운영체제가 디스크에 저장하기 위해 보낸 데이터는 디스크 캐시에 먼저 저장되고 프로세서가 디스크 캐시에서 플래터로 저장함, 디스크 입출력 응답 시간 감소

## 1.3 파일 입출력 주소

##### 디스크 물리 주소와 논리 블록 주소

파일 데이터는 운영체제에 의해 블록 크기로 디스크 내에 분산 저장된다
파일이 저장되고 읽혀지는 과정에서 서로 다른 주소가 사용된다

- 응용프로그램 - 파일 내 바이트 주소 사용
  - 파일 내 바이트의 위치(바이트 번호, 옵셋)를 사용하여 입출력
- 운영체제 - 논리 블록 주소 사용
  - LBA = 디스크의 모든 블록들을 일차원 배열로 나열하고 번호를 매긴 주소
- 디스크 장치 - 디스크 물리 주소 사용
  - CHS 물리주소 사용 = [실린더 번호, 헤드 번호, 섹터 번호]

##### 파일 주소 변환

> 파일 내바이트 주소 -> 논리 블록 주소 -> CHS 물리 주소

![[스크린샷 2024-06-18 11.11.51.png]]

##### 주소 계층화 의미

계층 구조로 인해 사용자나 응용 프로그램, 운영체제, 디스크 장치가 상호 독립적으로 정의된 기능을 수행

## 1.4 파일 시스템의 정의와 범위

> 파일 시스템은 저장 매체에 파일을 생성하고 저장하고 읽고 쓰는 운영체제의 기능을 통칭하는 말이다

파일 시스템의 범위

- 파일 시스템의 논리 구조
- 저장 장치에 파일 시스템 구축
- 커널 내 파일 입출력 구현
- 응용프로그램을 위한 파일 시스템 인터페이스

![[스크린샷 2024-06-18 12.23.27.png]]

## 1.5 파일 시스템 입출력 계층

파일 시스템은 파일이 입출력되는 모든 과정에서 관여한다

![[스크린샷 2024-06-18 12.24.27.png]]

##### 파일 읽기 과정을 통한 주목 사항

1. 파일 읽기의 과정은 계층 구조로 이루어지고 역할이 잘 구분된다.
2. 운영체제 커널의 역할은 사용자나 응용 프로그램이 파일이 저장되는 저장 장치의 종류나 구조, 위치 등에 대해서 알 필요 없이 입출력할 수 있도록 하는데 있다.
3. 파일에 대한 논리적 구조와 물리적 저장 공간을 분리시키는 것이 디스크 드라이버의 역할이다.
4. 파일 데이터는 디스크 헤드로부터 응용 프로그램 버퍼로 한번에 전송되지 않고 디스크 장치의 디스크 캐시, 커널의 버퍼 캐시, 라이브러리의 버퍼를 거쳐 복사된다.

# 2. 파일 시스템의 논리 구조

## 2.1 파일 시스템 구조

오늘날 운영체제는 대부분 많은 사용자와 응용프로그램에 의해 생성되는 수많은 파일을 관리하기 위해 트리 계층 구조로 파일 시스템을 구성한다.

##### 디렉터리와 파일의 계층 구조

디렉터리의 종류

- 루트 디렉터리(root directory) - 파일 시스템 계층 구조의 최상위 디렉터리
- 서브 디렉터리(sub directory) - 루트 디렉터리의 하부에 존재하는 디렉터리

![[스크린샷 2024-06-18 12.39.08.png]]

> 디렉터리는 서브 디렉터리나 파일들의 목록을 저장한 파일이다.

> [!Note] 디렉터리와 폴더
> 디렉터리가 파일을 담는 물리적인 컨테이너라면, 폴더는 파일뿐 아니라 네트워크 환경, 내 컴퓨터, 제어판 등 파일 개념이 아닌 여러 요소들도 담을 수 있는 논리적인 컨테이너이다.

##### 파일 이름과 경로명

파일 이름 - 이름(name)과 확장자(extension)으로 구성
경로명 - 루트 디렉터리에서부터 계층 구조를 포함하는 완전한 파일 이름

## 2.2 파일 시스템 메타 정보와 파일 메타 정보

운영체제는 파일 시스템을 다루기 위해 메타 정보를 만들고 활용한다

- 파일 시스템 메타 정보
- 파일 메타 정보

##### 파일 시스템 메타 정보

> 파일 시스템 전체에 대한 정보, 파일이나 디렉터리와 섞이지 않게 하고 운영체제가 쉽게 읽고 쓸 수 있도록 한다

- 파일 시스템 전체 크기
- 저장 장치에 구축된 파일 시스템의 현재 사용 크기
- 저장 장치에 구축된 파일 시스템의 비어 있는 크기
- 저장 장치 상에 비어있는 블록들의 리스트

##### 파일 메타 정보

> 파일에 관한 여러 정보

- 파일 이름, 크기
- 파일이 만들어진 시간, 수정된 시간
- 파일이 가장 최근에 액세스된 시간
- 파일을 만든 사용자(소유자)
- 파일 속성(접근 권한)
- 파일이 저장된 위치
  ![[스크린샷 2024-06-18 12.49.45.png]]

# 3. 파일 시스템 구축

## 3.1 파일 시스템 종류와 구현 이슈

디스크 상에 파일 시스템을 구축하기 위해서는 다음 이슈들을 해결해야 한다

- 디스크 장치에 비어 있는 블록들의 리스트를 어떻게 관리할 것인가?
- 파일 블록들을 디스크의 어느 영역에 분산 배치할 것인가?
- 파일 블록들이 저장된 디스크 내 위치들을 어떻게 관리할 것인가?

## 3.2 FAT(File Allocation Table) 파일 시스템

FAT 파일 시스템은 1980년대 MS-DOS 운영체제에서 사용된 파일 시스템이다.

##### FAT 파일 시스템의 구조

![[스크린샷 2024-06-18 12.51.54.png]]

##### 부트 섹터

- 파일 시스템 메타 정보 및 디스크에 관련된 정보들과 컴퓨터가 부팅할 때 실행되는 코드가 저장되는 영역
- 이 정보들을 이용해 파일 시스템 전체 크기를 알 수 있고 FAT 테이블 항목들을 조사하면 현재 파일 시스템 내사용중인 블록들과 비어있는 블록을 알 수 있음

##### FAT1과 FAT2

- FAT가 훼손되면 파일을 찾을수없기 때문에 FAT2를 복사본으로 둔다.

##### 루트 디렉터리

- 루트 디렉터리를 찾기 쉽도록 FAT2 바로 뒤에 구성하여 위치 고정

##### 데이터 블록 영역

- 루트 디렉터리를 제외한 모든 파일의 데이터 블록들이 저장되는 영역

##### 디렉터리

- 파일의 목록을 담은 파일
- 하나의 파일 메타 정보를 모두 저장
- 특히 **파일이 저장된 첫번째 디스크 블록 번호인 '시작 블록 번호'를 저장**
- 시작 블록 번호로부터 데이터 블록 영역에 분산된 파일 블록들을 찾아낼 수 있음

##### 파일 블록 배치(File Allocation)

- FAT 파일 시스템은 파일 데이터를 블록 단위로 디스크에 분산 저장하고 저장된 위치는 FAT 테이블에 기록
- 테이블의 항은 연결 리스트로 연결

![[스크린샷 2024-06-18 13.05.28.png]]

#### FAT 파일 시스템의 장단점

장점 : 단순하여 구현이 쉽고 디스크에 외부 단편화가 없다.
단점 : 파일 당 1/2 블록 크기로 내부 단편화가 발생하고, 디스크 헤드를 움직이는 탐색 시간이 크다. FAT 테이블 영역이 손상되면 파일 시스템 전체를 읽을 수 없다.

## 3.3 Unix 파일 시스템

##### Unix 파일 시스템의 구조

![[스크린샷 2024-06-18 13.15.17.png]]

##### 부트 블록(boot block)

- 부팅이 진행될 때 처음에 메모리로 적재되는 디스크 블록
- 운영체제를 적재하는 코드와 부팅 시 필요한 정보 저장

##### 수퍼 블록(super block)

- 파일 시스템 유지 관리를 위해 '파일 시스템 메타 정보'가 기록되는 공간

  - 파일 시스템 크기와 상태 정보
  - 블록 크기
  - 자유 블록 수
  - 자유 블록 리스트
  - 자유 블록 리스트에서 요청시 할당할 다음 블록 인덱스
  - i-node 리스트 크기
  - 자유 i-node 수
  - 자유 i-node 리스트
  - 자유 i-node 리스트에서 요청시 할당할 다음 자유 i-node 인덱스
  - 루트 디렉터리의 i-node 번호
  - 수퍼 블록이 갱신된 최근 시간

- 부팅 초기에 메모리에 적재되고, 적재된 수퍼블록은 파일 입출력동안 계속 갱신된다
- 백업 수퍼 블록을 두어 망가질 경우 복구

##### i-node와 i-node 리스트

![[스크린샷 2024-06-18 13.29.39.png]]

i-node(index node) : '파일 메타 정보'가 기록되는 구조체, 파일마다 한개씩 사용

- 파일이 만들어지면 운영체제는 i-node 리스트에서 자유 i-node를 하나 할당받아 파일 메타 정보들을 기록하고 관리한다.
- i-node 리스트의 크기와 자유 i-node 에 관한 정보는 수퍼 블록에 기록된다

##### 데이터 블록들

- 파일과 디렉터리가 저장되는 공간
- 블록 단위로 분산 저장

##### 디렉터리

- Unix에서 디렉터리는 여러 항목들로 이루어진 파일
- 파일이나 서브 디렉터리의 i-node 번호와 이름으로 구성

![[스크린샷 2024-06-18 13.42.41.png]]

##### 파일 블록 배치

- 파일을 블록 단위로 디스크의 여러 블록에 분산 저장하고, i-node에 15개의 인덱스를 통해 파일이 저장된 디스크 블록들의 번호를 기억한다

> 12개의 직접 인덱스 + 1개의 간접 인덱스 + 1개의 이중 간접 인덱스 + 1개의 3중 간접 인덱스

- 12개의 직접 인덱스(direct index)

  - 파일이 저장된 처음 12개의 디스크 블록 번호

- 1개의 간접 인덱스(single indirect index)

  - 파일이 12개의 블록을 넘어서 커지게 될 경우 i-node에 있는 간접 인덱스 사용
  - 1개의 디스크 블록을 할당받아 간접 인덱스로 가리키게 하고 이 디스크 블록을 파일 블록에 대한 인덱스로 사용

- 1개의 2중 간접 인덱스(double indirect index)
- 1개의 3중 간접 인덱스(triple indirect index)

##### 파일의 i-node를 찾는 과정

> /usr/source/main.c

![[스크린샷 2024-06-18 14.01.16.png]]

# 4. 파일 입출력 연산

## 4.1 파일 찾기

- 파일의 경로명으로부터 파일의 i-node를 찾는 과정, 커널에 의해 이루어짐

## 4.2 파일 열기, open()

1. 파일이 존재하는지 확인한다
2. 존재한다면 디스크에서 메모리로 i-node를 읽어들이고
3. 현재 프로세스가 파일 연산을 할 수 있는지 파일에 대한 접근 권한을 확인한다
4. 연이어 파일을 읽거나 쓰기 위한 커널 내에 자료 구조를 형성한다

![[스크린샷 2024-06-18 14.06.44.png]]

##### 파일 입출력을 위한 커널 자료 구조

- 메모리 i-node 테이블
  - 현재 열린 파일들에 대해 디스크에서 i-node를 읽어 메모리에 형성한 테이블
- 오픈 파일 테이블
  - 시스템 내 열려있는 모든 파일에 관한 정보 기록
- 프로세스별 오픈 테이블
  - 오픈 파일 테이블에 대한 메모리 주소 기록
- 버퍼 캐시
  - 파일을 읽고 쓰는 과정에서 파일 블록들을 일시적으로 저장하는 메모리 공간

##### 파일 디스크립터

- 열린 파일 마다 매겨진 고유한 정수 번호
- 프로세스별 오픈 파일 테이블의 인덱스

## 4.3 파일 읽기, read()

- 프로세스 별 오픈 파일 테이블 항목에 기록된 오픈 파일 테이블 주소를 따라 오픈 파일 테이블 항목을 액세스하고, 기록된 열기 모드를 검사하여 파일을 읽을 수 있는지 확인한 다음, 옵셋의 파일 위치에서 파일을 읽고 읽은 바이트 만큼 옵셋을 증가시킨다.

![[스크린샷 2024-06-18 15.05.12.png]]

## 4.4 파일 쓰기, write()

- 프로세스별 오픈 파일 테이블의 항목에 기록된 오픈 파일 테이블 주소를 따라 오픈 파일 테이블 항목을 액세스하고 이곳에 기록된 열기 모드를 검사하여 파일 쓰기가 가능한지 확인한 다음, 옵셋에 기록된 파일 ㅜ이치에서부터 파일에 기록하고 기록한 바이트 만큼 옵셋을 증가시킨다.

![[스크린샷 2024-06-18 15.05.41.png]]

## 4.5 파일 닫기, close()

- 프로세스 별 오픈 파일 테이블의 항목과 파일 테이블 항목을 반환하고, 메모리 i-node가 수정되었다면 디스크 i-node에 저장한다.
- close()가 실행되면 다시 열지 않는 한 파일은 입출력 할 수 없다.

![[스크린샷 2024-06-18 15.06.02.png]]

> [!Note] 동일한 파일을 동시에 여는 경우
> 각각 오픈 파일 테이블의 항목이 생기고 동일한 i-node를 공유한다
> 이후 파일 쓰기가 먼저 실행되면 그 뒤 실행되는 파일 읽기는 앞서 스기가 이루어진 파일 데이터를 읽게 되고 파일 읽기가 먼저 실행되면 원래 파일을 읽게 된다.
> 읽고 쓰는 순서에 따라 읽는 결과는 달라진다.

출처 - https://www.booksr.co.kr/product/%EB%AA%85%ED%92%88-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%88%98%EC%A0%95%ED%8C%90/

황기태, [명품 운영체제], 생능 출판사, 2023
